// Code generated by protoc-gen-go. DO NOT EDIT.
// source: aft.proto

package aft

import (
	context "context"
	fmt "fmt"
	proto "github.com/golang/protobuf/proto"
	empty "github.com/golang/protobuf/ptypes/empty"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
	math "math"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.ProtoPackageIsVersion3 // please upgrade the proto package

// An enum that tracks the status of each transaction.
type TransactionStatus int32

const (
	// The default status indicates that the transaction is currently running.
	TransactionStatus_RUNNING TransactionStatus = 0
	// This status indicates that the transaction has successfully committed.
	TransactionStatus_COMMITTED TransactionStatus = 1
	// This status indicates that the transaction has successfully aborted.
	TransactionStatus_ABORTED TransactionStatus = 2
)

var TransactionStatus_name = map[int32]string{
	0: "RUNNING",
	1: "COMMITTED",
	2: "ABORTED",
}

var TransactionStatus_value = map[string]int32{
	"RUNNING":   0,
	"COMMITTED": 1,
	"ABORTED":   2,
}

func (x TransactionStatus) String() string {
	return proto.EnumName(TransactionStatus_name, int32(x))
}

func (TransactionStatus) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_e7743263a823e9ed, []int{0}
}

// A token for clients to identify their current transaction.
type TransactionTag struct {
	// The ID of the transaction.
	Id string `protobuf:"bytes,1,opt,name=id,proto3" json:"id,omitempty"`
	// The current status of the transaction (see TransactionStatus).
	Status TransactionStatus `protobuf:"varint,2,opt,name=status,proto3,enum=TransactionStatus" json:"status,omitempty"`
	// The IP address of the replica that received the request.
	Address              string   `protobuf:"bytes,3,opt,name=address,proto3" json:"address,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *TransactionTag) Reset()         { *m = TransactionTag{} }
func (m *TransactionTag) String() string { return proto.CompactTextString(m) }
func (*TransactionTag) ProtoMessage()    {}
func (*TransactionTag) Descriptor() ([]byte, []int) {
	return fileDescriptor_e7743263a823e9ed, []int{0}
}

func (m *TransactionTag) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_TransactionTag.Unmarshal(m, b)
}
func (m *TransactionTag) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_TransactionTag.Marshal(b, m, deterministic)
}
func (m *TransactionTag) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TransactionTag.Merge(m, src)
}
func (m *TransactionTag) XXX_Size() int {
	return xxx_messageInfo_TransactionTag.Size(m)
}
func (m *TransactionTag) XXX_DiscardUnknown() {
	xxx_messageInfo_TransactionTag.DiscardUnknown(m)
}

var xxx_messageInfo_TransactionTag proto.InternalMessageInfo

func (m *TransactionTag) GetId() string {
	if m != nil {
		return m.Id
	}
	return ""
}

func (m *TransactionTag) GetStatus() TransactionStatus {
	if m != nil {
		return m.Status
	}
	return TransactionStatus_RUNNING
}

func (m *TransactionTag) GetAddress() string {
	if m != nil {
		return m.Address
	}
	return ""
}

// A message representing an individual transaction.
type TransactionRecord struct {
	// The UUID assigned to this transaction.
	Id string `protobuf:"bytes,1,opt,name=id,proto3" json:"id,omitempty"`
	// The sloppy timestamp given to this transaction by AFT.
	Timestamp int64 `protobuf:"varint,2,opt,name=timestamp,proto3" json:"timestamp,omitempty"`
	// The current status of the transaction (see TransactionStatus).
	Status TransactionStatus `protobuf:"varint,3,opt,name=status,proto3,enum=TransactionStatus" json:"status,omitempty"`
	// The UUID of the write buffer replica assigned to this transaction --
	// primarily used for debugging purposes.
	ReplicaId string `protobuf:"bytes,4,opt,name=replicaId,proto3" json:"replicaId,omitempty"`
	// The set of keys written by this transaction.
	WriteSet []string `protobuf:"bytes,5,rep,name=writeSet,proto3" json:"writeSet,omitempty"`
	// The set of keys that have been read by this transaction. This maps from
	// the user-facing key name to the actual key version read.
	ReadSet              map[string]string `protobuf:"bytes,6,rep,name=readSet,proto3" json:"readSet,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
	XXX_NoUnkeyedLiteral struct{}          `json:"-"`
	XXX_unrecognized     []byte            `json:"-"`
	XXX_sizecache        int32             `json:"-"`
}

func (m *TransactionRecord) Reset()         { *m = TransactionRecord{} }
func (m *TransactionRecord) String() string { return proto.CompactTextString(m) }
func (*TransactionRecord) ProtoMessage()    {}
func (*TransactionRecord) Descriptor() ([]byte, []int) {
	return fileDescriptor_e7743263a823e9ed, []int{1}
}

func (m *TransactionRecord) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_TransactionRecord.Unmarshal(m, b)
}
func (m *TransactionRecord) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_TransactionRecord.Marshal(b, m, deterministic)
}
func (m *TransactionRecord) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TransactionRecord.Merge(m, src)
}
func (m *TransactionRecord) XXX_Size() int {
	return xxx_messageInfo_TransactionRecord.Size(m)
}
func (m *TransactionRecord) XXX_DiscardUnknown() {
	xxx_messageInfo_TransactionRecord.DiscardUnknown(m)
}

var xxx_messageInfo_TransactionRecord proto.InternalMessageInfo

func (m *TransactionRecord) GetId() string {
	if m != nil {
		return m.Id
	}
	return ""
}

func (m *TransactionRecord) GetTimestamp() int64 {
	if m != nil {
		return m.Timestamp
	}
	return 0
}

func (m *TransactionRecord) GetStatus() TransactionStatus {
	if m != nil {
		return m.Status
	}
	return TransactionStatus_RUNNING
}

func (m *TransactionRecord) GetReplicaId() string {
	if m != nil {
		return m.ReplicaId
	}
	return ""
}

func (m *TransactionRecord) GetWriteSet() []string {
	if m != nil {
		return m.WriteSet
	}
	return nil
}

func (m *TransactionRecord) GetReadSet() map[string]string {
	if m != nil {
		return m.ReadSet
	}
	return nil
}

// Captures a list of `TransactionRecord`s, used to communicate committed
// transactions between replicas.
type TransactionList struct {
	// The list of `TransactionRecord`s being communicated.
	Records              []*TransactionRecord `protobuf:"bytes,1,rep,name=records,proto3" json:"records,omitempty"`
	XXX_NoUnkeyedLiteral struct{}             `json:"-"`
	XXX_unrecognized     []byte               `json:"-"`
	XXX_sizecache        int32                `json:"-"`
}

func (m *TransactionList) Reset()         { *m = TransactionList{} }
func (m *TransactionList) String() string { return proto.CompactTextString(m) }
func (*TransactionList) ProtoMessage()    {}
func (*TransactionList) Descriptor() ([]byte, []int) {
	return fileDescriptor_e7743263a823e9ed, []int{2}
}

func (m *TransactionList) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_TransactionList.Unmarshal(m, b)
}
func (m *TransactionList) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_TransactionList.Marshal(b, m, deterministic)
}
func (m *TransactionList) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TransactionList.Merge(m, src)
}
func (m *TransactionList) XXX_Size() int {
	return xxx_messageInfo_TransactionList.Size(m)
}
func (m *TransactionList) XXX_DiscardUnknown() {
	xxx_messageInfo_TransactionList.DiscardUnknown(m)
}

var xxx_messageInfo_TransactionList proto.InternalMessageInfo

func (m *TransactionList) GetRecords() []*TransactionRecord {
	if m != nil {
		return m.Records
	}
	return nil
}

// A list of transaction UUIDs that are communicated between the GC process and
// the Aft replicas.
type TransactionIdList struct {
	// The list of transaction UUIDs.
	Ids                  []string `protobuf:"bytes,1,rep,name=ids,proto3" json:"ids,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *TransactionIdList) Reset()         { *m = TransactionIdList{} }
func (m *TransactionIdList) String() string { return proto.CompactTextString(m) }
func (*TransactionIdList) ProtoMessage()    {}
func (*TransactionIdList) Descriptor() ([]byte, []int) {
	return fileDescriptor_e7743263a823e9ed, []int{3}
}

func (m *TransactionIdList) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_TransactionIdList.Unmarshal(m, b)
}
func (m *TransactionIdList) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_TransactionIdList.Marshal(b, m, deterministic)
}
func (m *TransactionIdList) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TransactionIdList.Merge(m, src)
}
func (m *TransactionIdList) XXX_Size() int {
	return xxx_messageInfo_TransactionIdList.Size(m)
}
func (m *TransactionIdList) XXX_DiscardUnknown() {
	xxx_messageInfo_TransactionIdList.DiscardUnknown(m)
}

var xxx_messageInfo_TransactionIdList proto.InternalMessageInfo

func (m *TransactionIdList) GetIds() []string {
	if m != nil {
		return m.Ids
	}
	return nil
}

// A request to read or write a key from an application to the storage engine.
type AftKeyRequest struct {
	// The transaction ID associated with this request.
	Tid string `protobuf:"bytes,1,opt,name=tid,proto3" json:"tid,omitempty"`
	// A list of requested keys, along with optional bytestrings for PUT requests.
	Pairs                []*AftKeyRequest_KeyPair `protobuf:"bytes,2,rep,name=pairs,proto3" json:"pairs,omitempty"`
	XXX_NoUnkeyedLiteral struct{}                 `json:"-"`
	XXX_unrecognized     []byte                   `json:"-"`
	XXX_sizecache        int32                    `json:"-"`
}

func (m *AftKeyRequest) Reset()         { *m = AftKeyRequest{} }
func (m *AftKeyRequest) String() string { return proto.CompactTextString(m) }
func (*AftKeyRequest) ProtoMessage()    {}
func (*AftKeyRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_e7743263a823e9ed, []int{4}
}

func (m *AftKeyRequest) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_AftKeyRequest.Unmarshal(m, b)
}
func (m *AftKeyRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_AftKeyRequest.Marshal(b, m, deterministic)
}
func (m *AftKeyRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AftKeyRequest.Merge(m, src)
}
func (m *AftKeyRequest) XXX_Size() int {
	return xxx_messageInfo_AftKeyRequest.Size(m)
}
func (m *AftKeyRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_AftKeyRequest.DiscardUnknown(m)
}

var xxx_messageInfo_AftKeyRequest proto.InternalMessageInfo

func (m *AftKeyRequest) GetTid() string {
	if m != nil {
		return m.Tid
	}
	return ""
}

func (m *AftKeyRequest) GetPairs() []*AftKeyRequest_KeyPair {
	if m != nil {
		return m.Pairs
	}
	return nil
}

// A request to read or write an individual key. If the value is specified,
// the request is treated as a write, and if it is not, the request is
// treated as a read.
type AftKeyRequest_KeyPair struct {
	// The key being requested.
	Key string `protobuf:"bytes,1,opt,name=key,proto3" json:"key,omitempty"`
	// An optional value for write requests.
	Value                []byte   `protobuf:"bytes,2,opt,name=value,proto3" json:"value,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *AftKeyRequest_KeyPair) Reset()         { *m = AftKeyRequest_KeyPair{} }
func (m *AftKeyRequest_KeyPair) String() string { return proto.CompactTextString(m) }
func (*AftKeyRequest_KeyPair) ProtoMessage()    {}
func (*AftKeyRequest_KeyPair) Descriptor() ([]byte, []int) {
	return fileDescriptor_e7743263a823e9ed, []int{4, 0}
}

func (m *AftKeyRequest_KeyPair) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_AftKeyRequest_KeyPair.Unmarshal(m, b)
}
func (m *AftKeyRequest_KeyPair) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_AftKeyRequest_KeyPair.Marshal(b, m, deterministic)
}
func (m *AftKeyRequest_KeyPair) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AftKeyRequest_KeyPair.Merge(m, src)
}
func (m *AftKeyRequest_KeyPair) XXX_Size() int {
	return xxx_messageInfo_AftKeyRequest_KeyPair.Size(m)
}
func (m *AftKeyRequest_KeyPair) XXX_DiscardUnknown() {
	xxx_messageInfo_AftKeyRequest_KeyPair.DiscardUnknown(m)
}

var xxx_messageInfo_AftKeyRequest_KeyPair proto.InternalMessageInfo

func (m *AftKeyRequest_KeyPair) GetKey() string {
	if m != nil {
		return m.Key
	}
	return ""
}

func (m *AftKeyRequest_KeyPair) GetValue() []byte {
	if m != nil {
		return m.Value
	}
	return nil
}

// A message to represent an update to an individual key, written to the
// storagen engine.
type KeyValuePair struct {
	// The plain key name for this key-value pair. The storage engine key might
	// vary, depending on the versioning scheme, but this is the user-facing key.
	Key string `protobuf:"bytes,1,opt,name=key,proto3" json:"key,omitempty"`
	// The payload for this key-value pair.
	Value []byte `protobuf:"bytes,2,opt,name=value,proto3" json:"value,omitempty"`
	// The set of keys written along with this key.
	CowrittenKeys []string `protobuf:"bytes,3,rep,name=cowrittenKeys,proto3" json:"cowrittenKeys,omitempty"`
	// The UUID of the transaction that wrote this update.
	Tid string `protobuf:"bytes,4,opt,name=tid,proto3" json:"tid,omitempty"`
	// The timestamp associated with the transaction that wrote this update.
	Timestamp            int64    `protobuf:"varint,5,opt,name=timestamp,proto3" json:"timestamp,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *KeyValuePair) Reset()         { *m = KeyValuePair{} }
func (m *KeyValuePair) String() string { return proto.CompactTextString(m) }
func (*KeyValuePair) ProtoMessage()    {}
func (*KeyValuePair) Descriptor() ([]byte, []int) {
	return fileDescriptor_e7743263a823e9ed, []int{5}
}

func (m *KeyValuePair) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_KeyValuePair.Unmarshal(m, b)
}
func (m *KeyValuePair) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_KeyValuePair.Marshal(b, m, deterministic)
}
func (m *KeyValuePair) XXX_Merge(src proto.Message) {
	xxx_messageInfo_KeyValuePair.Merge(m, src)
}
func (m *KeyValuePair) XXX_Size() int {
	return xxx_messageInfo_KeyValuePair.Size(m)
}
func (m *KeyValuePair) XXX_DiscardUnknown() {
	xxx_messageInfo_KeyValuePair.DiscardUnknown(m)
}

var xxx_messageInfo_KeyValuePair proto.InternalMessageInfo

func (m *KeyValuePair) GetKey() string {
	if m != nil {
		return m.Key
	}
	return ""
}

func (m *KeyValuePair) GetValue() []byte {
	if m != nil {
		return m.Value
	}
	return nil
}

func (m *KeyValuePair) GetCowrittenKeys() []string {
	if m != nil {
		return m.CowrittenKeys
	}
	return nil
}

func (m *KeyValuePair) GetTid() string {
	if m != nil {
		return m.Tid
	}
	return ""
}

func (m *KeyValuePair) GetTimestamp() int64 {
	if m != nil {
		return m.Timestamp
	}
	return 0
}

// A request from a client to the AFT cache to update itself with  a
// transaction's metadata.
type MetadataRequest struct {
	// The ID of the transaction to retrieve.
	Tid string `protobuf:"bytes,1,opt,name=tid,proto3" json:"tid,omitempty"`
	// The address at which to send the response.
	ResponseAddress string `protobuf:"bytes,2,opt,name=responseAddress,proto3" json:"responseAddress,omitempty"`
	// The address of the cache immediately preceding this one.
	Address              string   `protobuf:"bytes,3,opt,name=address,proto3" json:"address,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *MetadataRequest) Reset()         { *m = MetadataRequest{} }
func (m *MetadataRequest) String() string { return proto.CompactTextString(m) }
func (*MetadataRequest) ProtoMessage()    {}
func (*MetadataRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_e7743263a823e9ed, []int{6}
}

func (m *MetadataRequest) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_MetadataRequest.Unmarshal(m, b)
}
func (m *MetadataRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_MetadataRequest.Marshal(b, m, deterministic)
}
func (m *MetadataRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MetadataRequest.Merge(m, src)
}
func (m *MetadataRequest) XXX_Size() int {
	return xxx_messageInfo_MetadataRequest.Size(m)
}
func (m *MetadataRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_MetadataRequest.DiscardUnknown(m)
}

var xxx_messageInfo_MetadataRequest proto.InternalMessageInfo

func (m *MetadataRequest) GetTid() string {
	if m != nil {
		return m.Tid
	}
	return ""
}

func (m *MetadataRequest) GetResponseAddress() string {
	if m != nil {
		return m.ResponseAddress
	}
	return ""
}

func (m *MetadataRequest) GetAddress() string {
	if m != nil {
		return m.Address
	}
	return ""
}

// A request from a client to a cache to commit a transaction.
type CommitRequest struct {
	// The ID of the transaction to commmit.
	Tid string `protobuf:"bytes,1,opt,name=tid,proto3" json:"tid,omitempty"`
	// The address at which to send the response.
	ResponseAddress string `protobuf:"bytes,2,opt,name=responseAddress,proto3" json:"responseAddress,omitempty"`
	// The addresses of all caches involved in the transaction.
	Addresses            []string `protobuf:"bytes,3,rep,name=addresses,proto3" json:"addresses,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *CommitRequest) Reset()         { *m = CommitRequest{} }
func (m *CommitRequest) String() string { return proto.CompactTextString(m) }
func (*CommitRequest) ProtoMessage()    {}
func (*CommitRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_e7743263a823e9ed, []int{7}
}

func (m *CommitRequest) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_CommitRequest.Unmarshal(m, b)
}
func (m *CommitRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_CommitRequest.Marshal(b, m, deterministic)
}
func (m *CommitRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CommitRequest.Merge(m, src)
}
func (m *CommitRequest) XXX_Size() int {
	return xxx_messageInfo_CommitRequest.Size(m)
}
func (m *CommitRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_CommitRequest.DiscardUnknown(m)
}

var xxx_messageInfo_CommitRequest proto.InternalMessageInfo

func (m *CommitRequest) GetTid() string {
	if m != nil {
		return m.Tid
	}
	return ""
}

func (m *CommitRequest) GetResponseAddress() string {
	if m != nil {
		return m.ResponseAddress
	}
	return ""
}

func (m *CommitRequest) GetAddresses() []string {
	if m != nil {
		return m.Addresses
	}
	return nil
}

// A request from one AFT cache to another to commit a (part of) a transaction.
type AftCommitRequest struct {
	// The metadata of the transaction to commit.
	Record *TransactionRecord `protobuf:"bytes,1,opt,name=record,proto3" json:"record,omitempty"`
	// The address at which the receiving node should acknowledge success.
	ResponseAddress      string   `protobuf:"bytes,2,opt,name=responseAddress,proto3" json:"responseAddress,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *AftCommitRequest) Reset()         { *m = AftCommitRequest{} }
func (m *AftCommitRequest) String() string { return proto.CompactTextString(m) }
func (*AftCommitRequest) ProtoMessage()    {}
func (*AftCommitRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_e7743263a823e9ed, []int{8}
}

func (m *AftCommitRequest) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_AftCommitRequest.Unmarshal(m, b)
}
func (m *AftCommitRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_AftCommitRequest.Marshal(b, m, deterministic)
}
func (m *AftCommitRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AftCommitRequest.Merge(m, src)
}
func (m *AftCommitRequest) XXX_Size() int {
	return xxx_messageInfo_AftCommitRequest.Size(m)
}
func (m *AftCommitRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_AftCommitRequest.DiscardUnknown(m)
}

var xxx_messageInfo_AftCommitRequest proto.InternalMessageInfo

func (m *AftCommitRequest) GetRecord() *TransactionRecord {
	if m != nil {
		return m.Record
	}
	return nil
}

func (m *AftCommitRequest) GetResponseAddress() string {
	if m != nil {
		return m.ResponseAddress
	}
	return ""
}

// A query for a previously written key (within a transaction) between two AFT
// nodes.
type AftQuery struct {
	// The key to request.
	Key string `protobuf:"bytes,1,opt,name=key,proto3" json:"key,omitempty"`
	// The ID of the transaction in which the read is being done.
	Tid string `protobuf:"bytes,2,opt,name=tid,proto3" json:"tid,omitempty"`
	// The address to which the response should be sent.
	ResponseAddress      string   `protobuf:"bytes,3,opt,name=responseAddress,proto3" json:"responseAddress,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *AftQuery) Reset()         { *m = AftQuery{} }
func (m *AftQuery) String() string { return proto.CompactTextString(m) }
func (*AftQuery) ProtoMessage()    {}
func (*AftQuery) Descriptor() ([]byte, []int) {
	return fileDescriptor_e7743263a823e9ed, []int{9}
}

func (m *AftQuery) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_AftQuery.Unmarshal(m, b)
}
func (m *AftQuery) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_AftQuery.Marshal(b, m, deterministic)
}
func (m *AftQuery) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AftQuery.Merge(m, src)
}
func (m *AftQuery) XXX_Size() int {
	return xxx_messageInfo_AftQuery.Size(m)
}
func (m *AftQuery) XXX_DiscardUnknown() {
	xxx_messageInfo_AftQuery.DiscardUnknown(m)
}

var xxx_messageInfo_AftQuery proto.InternalMessageInfo

func (m *AftQuery) GetKey() string {
	if m != nil {
		return m.Key
	}
	return ""
}

func (m *AftQuery) GetTid() string {
	if m != nil {
		return m.Tid
	}
	return ""
}

func (m *AftQuery) GetResponseAddress() string {
	if m != nil {
		return m.ResponseAddress
	}
	return ""
}

// A response sent from one AFT cache to another in response to an AftQuery.
type AftResponse struct {
	// The key of the resopnse.
	Key string `protobuf:"bytes,1,opt,name=key,proto3" json:"key,omitempty"`
	// Whether the key was found in this cache or not.
	Found bool `protobuf:"varint,2,opt,name=found,proto3" json:"found,omitempty"`
	// If the key was not found, this field contains a pointer to the next cache
	// in the chain that should be queried.
	Pointer string `protobuf:"bytes,3,opt,name=pointer,proto3" json:"pointer,omitempty"`
	// If the key was found, the data associated with the key.
	Data                 []byte   `protobuf:"bytes,4,opt,name=data,proto3" json:"data,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *AftResponse) Reset()         { *m = AftResponse{} }
func (m *AftResponse) String() string { return proto.CompactTextString(m) }
func (*AftResponse) ProtoMessage()    {}
func (*AftResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_e7743263a823e9ed, []int{10}
}

func (m *AftResponse) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_AftResponse.Unmarshal(m, b)
}
func (m *AftResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_AftResponse.Marshal(b, m, deterministic)
}
func (m *AftResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AftResponse.Merge(m, src)
}
func (m *AftResponse) XXX_Size() int {
	return xxx_messageInfo_AftResponse.Size(m)
}
func (m *AftResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_AftResponse.DiscardUnknown(m)
}

var xxx_messageInfo_AftResponse proto.InternalMessageInfo

func (m *AftResponse) GetKey() string {
	if m != nil {
		return m.Key
	}
	return ""
}

func (m *AftResponse) GetFound() bool {
	if m != nil {
		return m.Found
	}
	return false
}

func (m *AftResponse) GetPointer() string {
	if m != nil {
		return m.Pointer
	}
	return ""
}

func (m *AftResponse) GetData() []byte {
	if m != nil {
		return m.Data
	}
	return nil
}

func init() {
	proto.RegisterEnum("TransactionStatus", TransactionStatus_name, TransactionStatus_value)
	proto.RegisterType((*TransactionTag)(nil), "TransactionTag")
	proto.RegisterType((*TransactionRecord)(nil), "TransactionRecord")
	proto.RegisterMapType((map[string]string)(nil), "TransactionRecord.ReadSetEntry")
	proto.RegisterType((*TransactionList)(nil), "TransactionList")
	proto.RegisterType((*TransactionIdList)(nil), "TransactionIdList")
	proto.RegisterType((*AftKeyRequest)(nil), "AftKeyRequest")
	proto.RegisterType((*AftKeyRequest_KeyPair)(nil), "AftKeyRequest.KeyPair")
	proto.RegisterType((*KeyValuePair)(nil), "KeyValuePair")
	proto.RegisterType((*MetadataRequest)(nil), "MetadataRequest")
	proto.RegisterType((*CommitRequest)(nil), "CommitRequest")
	proto.RegisterType((*AftCommitRequest)(nil), "AftCommitRequest")
	proto.RegisterType((*AftQuery)(nil), "AftQuery")
	proto.RegisterType((*AftResponse)(nil), "AftResponse")
}

func init() { proto.RegisterFile("aft.proto", fileDescriptor_e7743263a823e9ed) }

var fileDescriptor_e7743263a823e9ed = []byte{
	// 663 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xac, 0x54, 0x59, 0x6f, 0xd3, 0x4e,
	0x10, 0xaf, 0xed, 0x1c, 0xf5, 0x34, 0x87, 0xbb, 0xfa, 0xab, 0xb2, 0xf2, 0xaf, 0x44, 0x64, 0x81,
	0x14, 0xaa, 0xca, 0x15, 0x45, 0xe2, 0xa8, 0x40, 0xc8, 0x94, 0x0a, 0x45, 0xa1, 0x2d, 0x6c, 0xc3,
	0xf1, 0xba, 0x8d, 0xd7, 0x61, 0x45, 0x63, 0x9b, 0xf5, 0x1a, 0xe4, 0x57, 0x1e, 0x11, 0x9f, 0x81,
	0xcf, 0x8a, 0xd6, 0x47, 0x63, 0x27, 0xa1, 0x87, 0xc4, 0xdb, 0xce, 0xf9, 0x9b, 0xdf, 0xcc, 0xec,
	0x80, 0x4e, 0x3c, 0x61, 0x87, 0x3c, 0x10, 0x41, 0xef, 0xff, 0x69, 0x10, 0x4c, 0x2f, 0xe8, 0x5e,
	0x2a, 0x9d, 0xc7, 0xde, 0x1e, 0x9d, 0x85, 0x22, 0xc9, 0x8c, 0x96, 0x07, 0x9d, 0x31, 0x27, 0x7e,
	0x44, 0x26, 0x82, 0x05, 0xfe, 0x98, 0x4c, 0x51, 0x07, 0x54, 0xe6, 0x9a, 0x4a, 0x5f, 0x19, 0xe8,
	0x58, 0x65, 0x2e, 0xda, 0x81, 0x46, 0x24, 0x88, 0x88, 0x23, 0x53, 0xed, 0x2b, 0x83, 0xce, 0x3e,
	0xb2, 0x4b, 0x01, 0x67, 0xa9, 0x05, 0xe7, 0x1e, 0xc8, 0x84, 0x26, 0x71, 0x5d, 0x4e, 0xa3, 0xc8,
	0xd4, 0xd2, 0x04, 0x85, 0x68, 0xfd, 0x56, 0x61, 0xb3, 0x14, 0x87, 0xe9, 0x24, 0xe0, 0xee, 0x12,
	0xd6, 0x36, 0xe8, 0x82, 0xcd, 0x68, 0x24, 0xc8, 0x2c, 0x4c, 0xe1, 0x34, 0x3c, 0x57, 0x94, 0x2a,
	0xd1, 0xae, 0xad, 0x64, 0x1b, 0x74, 0x4e, 0xc3, 0x0b, 0x36, 0x21, 0x43, 0xd7, 0xac, 0xa5, 0x00,
	0x73, 0x05, 0xea, 0xc1, 0xfa, 0x77, 0xce, 0x04, 0x3d, 0xa3, 0xc2, 0xac, 0xf7, 0xb5, 0x81, 0x8e,
	0x2f, 0x65, 0xf4, 0x14, 0x9a, 0x9c, 0x12, 0x57, 0x9a, 0x1a, 0x7d, 0x6d, 0xb0, 0xb1, 0x7f, 0xc7,
	0x5e, 0x2a, 0xdc, 0xc6, 0x99, 0xc7, 0x91, 0x2f, 0x78, 0x82, 0x0b, 0xff, 0xde, 0x01, 0xb4, 0xca,
	0x06, 0x64, 0x80, 0xf6, 0x85, 0x26, 0x39, 0x3f, 0xf9, 0x44, 0xff, 0x41, 0xfd, 0x1b, 0xb9, 0x88,
	0x69, 0x4a, 0x4e, 0xc7, 0x99, 0x70, 0xa0, 0x3e, 0x51, 0xac, 0x17, 0xd0, 0x2d, 0xc1, 0xbc, 0x61,
	0x91, 0x40, 0xbb, 0xb2, 0x12, 0x09, 0x17, 0x99, 0x4a, 0x5a, 0x09, 0x5a, 0xae, 0x04, 0x17, 0x2e,
	0xd6, 0xbd, 0x4a, 0x83, 0x87, 0x6e, 0x9a, 0xc2, 0x00, 0x8d, 0xe5, 0xe1, 0x3a, 0x96, 0x4f, 0xeb,
	0x87, 0x02, 0x6d, 0xc7, 0x13, 0x23, 0x9a, 0x60, 0xfa, 0x35, 0xa6, 0x99, 0x8f, 0xb8, 0x9c, 0x82,
	0x7c, 0xa2, 0x5d, 0xa8, 0x87, 0x84, 0x71, 0x39, 0x71, 0x09, 0xbb, 0x65, 0x57, 0x02, 0xec, 0x11,
	0x4d, 0xde, 0x12, 0xc6, 0x71, 0xe6, 0xd4, 0x7b, 0x00, 0xcd, 0x5c, 0x73, 0x1d, 0xe1, 0x56, 0x4e,
	0xd8, 0xfa, 0xa5, 0x40, 0x6b, 0x44, 0x93, 0x0f, 0x52, 0xb8, 0x4d, 0x20, 0xba, 0x0b, 0xed, 0x49,
	0x20, 0x47, 0x25, 0xa8, 0x3f, 0xa2, 0x89, 0xdc, 0x04, 0xc9, 0xac, 0xaa, 0x2c, 0x18, 0xd5, 0xe6,
	0x8c, 0x2a, 0x8b, 0x55, 0x5f, 0x58, 0x2c, 0x6b, 0x0a, 0xdd, 0x63, 0x2a, 0x88, 0x4b, 0x04, 0xf9,
	0x7b, 0x53, 0x06, 0xd0, 0xe5, 0x34, 0x0a, 0x03, 0x3f, 0xa2, 0x4e, 0xbe, 0xe3, 0xd9, 0x10, 0x17,
	0xd5, 0x57, 0xfc, 0x02, 0x06, 0xed, 0xc3, 0x60, 0x36, 0x63, 0xe2, 0x5f, 0xc0, 0x6c, 0x83, 0x9e,
	0xe7, 0xa5, 0x45, 0x1f, 0xe6, 0x0a, 0xeb, 0x33, 0x18, 0x8e, 0x27, 0xaa, 0x68, 0x3b, 0xd0, 0xc8,
	0xb6, 0x25, 0x05, 0x5c, 0xbd, 0x4f, 0xb9, 0xc7, 0xcd, 0xeb, 0xb0, 0x3e, 0xc1, 0xba, 0xe3, 0x89,
	0x77, 0x31, 0x5d, 0xb9, 0xf1, 0x39, 0x43, 0xf5, 0x4a, 0x86, 0xda, 0xea, 0xcc, 0x13, 0xd8, 0x70,
	0x3c, 0x81, 0x73, 0xed, 0xea, 0x25, 0xf1, 0x82, 0xd8, 0xcf, 0xd2, 0xaf, 0xe3, 0x4c, 0x90, 0xfd,
	0x0f, 0x03, 0xe6, 0x0b, 0xca, 0x8b, 0xfe, 0xe7, 0x22, 0x42, 0x50, 0x93, 0x43, 0x4e, 0x37, 0xa3,
	0x85, 0xd3, 0xf7, 0xce, 0xb3, 0xca, 0xbf, 0xc9, 0xce, 0x08, 0xda, 0x80, 0x26, 0x7e, 0x7f, 0x72,
	0x32, 0x3c, 0x79, 0x6d, 0xac, 0xa1, 0x36, 0xe8, 0x87, 0xa7, 0xc7, 0xc7, 0xc3, 0xf1, 0xf8, 0xe8,
	0x95, 0xa1, 0x48, 0x9b, 0xf3, 0xf2, 0x14, 0x4b, 0x41, 0xdd, 0xff, 0xa9, 0x82, 0xe6, 0x78, 0x02,
	0x3d, 0x07, 0xe3, 0x4c, 0x10, 0x2e, 0x4a, 0xa9, 0xd0, 0x96, 0x9d, 0x5d, 0x5e, 0xbb, 0xb8, 0xbc,
	0xf6, 0x91, 0xbc, 0xbc, 0xbd, 0xae, 0x5d, 0x3d, 0xb9, 0xd6, 0x1a, 0xba, 0x0f, 0xf5, 0x8f, 0xf2,
	0x00, 0xa1, 0x4e, 0xf5, 0xaf, 0xf5, 0x16, 0x64, 0x6b, 0x0d, 0x0d, 0xa0, 0x26, 0x8f, 0xcc, 0x0d,
	0x3c, 0x1f, 0xc3, 0x66, 0x36, 0xff, 0x72, 0x51, 0x8b, 0xe0, 0xab, 0xaa, 0x79, 0x04, 0x86, 0x73,
	0x1e, 0xf0, 0xdb, 0xc6, 0x9d, 0x37, 0x52, 0xa2, 0x0f, 0xff, 0x04, 0x00, 0x00, 0xff, 0xff, 0x7b,
	0x31, 0xd6, 0x6c, 0x7d, 0x06, 0x00, 0x00,
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// AftClient is the client API for Aft service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://godoc.org/google.golang.org/grpc#ClientConn.NewStream.
type AftClient interface {
	// Starts a new transaction in the system and returns a unique transaction
	// ID. The updates made in the context of this transaction will not be
	// persisted until CommitTransaction is called.
	StartTransaction(ctx context.Context, in *empty.Empty, opts ...grpc.CallOption) (*TransactionTag, error)
	// Tentatively write a value or batch of values to the storage engine. These
	// writes will not be committed until CommitTransaction is called. If
	// AbortTransaction is called, these writes will be dropped.
	Write(ctx context.Context, in *AftKeyRequest, opts ...grpc.CallOption) (*AftKeyRequest, error)
	// Retrieve a value from the storage engine.
	Read(ctx context.Context, in *AftKeyRequest, opts ...grpc.CallOption) (*AftKeyRequest, error)
	// Commits buffered writes to the storage engine. The commit is not
	// guaranteed to succeed and may depend on the isolation mechanisms being
	// used in order to determine whether the transactions updates and reads are
	// valid.
	CommitTransaction(ctx context.Context, in *TransactionTag, opts ...grpc.CallOption) (*TransactionTag, error)
	// Aborts all of the updates made by this transaction. The buffered updates
	// will be dropped, and the transaction in the underlying engine will be
	// closed.
	AbortTransaction(ctx context.Context, in *TransactionTag, opts ...grpc.CallOption) (*TransactionTag, error)
}

type aftClient struct {
	cc *grpc.ClientConn
}

func NewAftClient(cc *grpc.ClientConn) AftClient {
	return &aftClient{cc}
}

func (c *aftClient) StartTransaction(ctx context.Context, in *empty.Empty, opts ...grpc.CallOption) (*TransactionTag, error) {
	out := new(TransactionTag)
	err := c.cc.Invoke(ctx, "/Aft/StartTransaction", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *aftClient) Write(ctx context.Context, in *AftKeyRequest, opts ...grpc.CallOption) (*AftKeyRequest, error) {
	out := new(AftKeyRequest)
	err := c.cc.Invoke(ctx, "/Aft/Write", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *aftClient) Read(ctx context.Context, in *AftKeyRequest, opts ...grpc.CallOption) (*AftKeyRequest, error) {
	out := new(AftKeyRequest)
	err := c.cc.Invoke(ctx, "/Aft/Read", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *aftClient) CommitTransaction(ctx context.Context, in *TransactionTag, opts ...grpc.CallOption) (*TransactionTag, error) {
	out := new(TransactionTag)
	err := c.cc.Invoke(ctx, "/Aft/CommitTransaction", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *aftClient) AbortTransaction(ctx context.Context, in *TransactionTag, opts ...grpc.CallOption) (*TransactionTag, error) {
	out := new(TransactionTag)
	err := c.cc.Invoke(ctx, "/Aft/AbortTransaction", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// AftServer is the server API for Aft service.
type AftServer interface {
	// Starts a new transaction in the system and returns a unique transaction
	// ID. The updates made in the context of this transaction will not be
	// persisted until CommitTransaction is called.
	StartTransaction(context.Context, *empty.Empty) (*TransactionTag, error)
	// Tentatively write a value or batch of values to the storage engine. These
	// writes will not be committed until CommitTransaction is called. If
	// AbortTransaction is called, these writes will be dropped.
	Write(context.Context, *AftKeyRequest) (*AftKeyRequest, error)
	// Retrieve a value from the storage engine.
	Read(context.Context, *AftKeyRequest) (*AftKeyRequest, error)
	// Commits buffered writes to the storage engine. The commit is not
	// guaranteed to succeed and may depend on the isolation mechanisms being
	// used in order to determine whether the transactions updates and reads are
	// valid.
	CommitTransaction(context.Context, *TransactionTag) (*TransactionTag, error)
	// Aborts all of the updates made by this transaction. The buffered updates
	// will be dropped, and the transaction in the underlying engine will be
	// closed.
	AbortTransaction(context.Context, *TransactionTag) (*TransactionTag, error)
}

// UnimplementedAftServer can be embedded to have forward compatible implementations.
type UnimplementedAftServer struct {
}

func (*UnimplementedAftServer) StartTransaction(ctx context.Context, req *empty.Empty) (*TransactionTag, error) {
	return nil, status.Errorf(codes.Unimplemented, "method StartTransaction not implemented")
}
func (*UnimplementedAftServer) Write(ctx context.Context, req *AftKeyRequest) (*AftKeyRequest, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Write not implemented")
}
func (*UnimplementedAftServer) Read(ctx context.Context, req *AftKeyRequest) (*AftKeyRequest, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Read not implemented")
}
func (*UnimplementedAftServer) CommitTransaction(ctx context.Context, req *TransactionTag) (*TransactionTag, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CommitTransaction not implemented")
}
func (*UnimplementedAftServer) AbortTransaction(ctx context.Context, req *TransactionTag) (*TransactionTag, error) {
	return nil, status.Errorf(codes.Unimplemented, "method AbortTransaction not implemented")
}

func RegisterAftServer(s *grpc.Server, srv AftServer) {
	s.RegisterService(&_Aft_serviceDesc, srv)
}

func _Aft_StartTransaction_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(empty.Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AftServer).StartTransaction(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/Aft/StartTransaction",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AftServer).StartTransaction(ctx, req.(*empty.Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _Aft_Write_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(AftKeyRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AftServer).Write(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/Aft/Write",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AftServer).Write(ctx, req.(*AftKeyRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Aft_Read_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(AftKeyRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AftServer).Read(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/Aft/Read",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AftServer).Read(ctx, req.(*AftKeyRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Aft_CommitTransaction_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(TransactionTag)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AftServer).CommitTransaction(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/Aft/CommitTransaction",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AftServer).CommitTransaction(ctx, req.(*TransactionTag))
	}
	return interceptor(ctx, in, info, handler)
}

func _Aft_AbortTransaction_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(TransactionTag)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AftServer).AbortTransaction(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/Aft/AbortTransaction",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AftServer).AbortTransaction(ctx, req.(*TransactionTag))
	}
	return interceptor(ctx, in, info, handler)
}

var _Aft_serviceDesc = grpc.ServiceDesc{
	ServiceName: "Aft",
	HandlerType: (*AftServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "StartTransaction",
			Handler:    _Aft_StartTransaction_Handler,
		},
		{
			MethodName: "Write",
			Handler:    _Aft_Write_Handler,
		},
		{
			MethodName: "Read",
			Handler:    _Aft_Read_Handler,
		},
		{
			MethodName: "CommitTransaction",
			Handler:    _Aft_CommitTransaction_Handler,
		},
		{
			MethodName: "AbortTransaction",
			Handler:    _Aft_AbortTransaction_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "aft.proto",
}
